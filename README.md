# <h1>Java_Themes</h1></p>
В данном проекте распологаются приложения, в которых рассматриваются основные темы языка Java, такие как Java Core, Java Collection API и др., для более эффективной подготовки к собеседованию.</p> Описание проектов приложено ниже, которое добавлятся по мере добавления приложений.</p>
 _ _ _ _
_**Краткое описание приложений:**_</p>

- _AggregationAndComposition_ - рассматриваются основные определения ООП: создание экземпляров класса, наследование, задание значений полей класса и основные приёмы ассоциации: агрегации и композиции и их описанием.</p>
- _Interface_AbstractClass_ - на примере рассматриваются основные понятия абстакции, полиморфизма. </p>
_ _ _ _
  <h2>Описание тем на практике, используя приложения по представленной выше ссылке</h2></p>
 - <em>AggregationAndComposition-> https://github.com/Krassilnikov-AV/Java_Themes/tree/master/Java_Themes_OOP/src/main/java/oop/aggregationAndComposition/project_1 описание⬇️</em> </p>
 
<h5>Объектно ориентированное программирование (ООП) - это методология программирования, основанная на представлении программного
продукта в виде совокупности объектов, каждый из которых является экземпляром
конкретного класса.</h5> ООП использует в качестве базовых элементов взаимодействие объектов.</p>
<em> Объект </em>- именнованная модель реальной сущности, обладающая конкретными значениями свойств и проявляющая свое поведение, обладающий именем набора данных (полей и свойств объекта), физически находящихся в памяти компьютера, и методов, имеющих доступ к ним. Объект -это конкретный экземпляр класса.</p>

<strong>Объектно-ориентированное программирование строится на 4-х основных принципах:</strong></p>
1. Наследование</p>
2. Инкапсуляция</p>
3. Полиморфизм</p>
4. Абстракция</p>
<h2><strong>Наследование</strong></h2> -  это процесс благодаря которому один объект может приобрести свойства другого объекта (наследование всех свойств одного объекта другим) и добавлять черты характерны только для него самого!</p>

 В приложении применено наследование, вызываемого объекта класса потомка будет зависит от класса родителя (пример вызова экземпляра класса Truck) </p>
 Особенности наследования:</p>
  - вызов экземпляров класса наследника через класс родитель;</p>
  - можно переопределять методы класса родителя или не переопределять;</p>
  - создавать свои методы класса, расширяя функционал класса родителя</p>
<strong>Главным преимуществом наследования, является ВОЗМОЖНОСТЬ ИСПОЛЬЗОВАНИЯ ПОВТОРНОГО КОДА. </strong>  </p>
<h2>Отношения между объектами:</h2></p>
Классы и объекты могут быть связаны друг с другом. Наследование описывает связь «является» (или по-английски «IS A»). В нашем примере класс Cabriolet является автомобилем, т.е. наследником класса Car. Такое отношение легко выразить с помощью наследования, где Car будет родительским классом, а Cabriolet — потомком.</p>

![потомок автомобиля](https://user-images.githubusercontent.com/61631173/127644064-d7653122-db54-4a50-aaaa-3cd70226f2de.JPG)</p>

Однако не все связи отношения в мире описываются таким образом. К примеру, клавиатура определенно как-то связана с компьютером, но она не является компьютером. Руки как-то связаны с человеком, но они не являются человеком.</p>
В этих случаях в его основе лежит другой тип отношения: не «является», а «является частью» («HAS A»). Рука не является человеком, но является частью человека. Клавиатура не является компьютером, но является частью компьютера.</p>

Теоия ООП выделяет три основных отношения между классами:</p>
- Ассоциация;</p>
- Агрегация и композиция;</p>
- Обобщение/Расширение (наследование).</p>

Отношения _HAS A_ можно описать в коде, используя механизмы композиции и агрегирования. Разница между ними заключается в «строгости» этих связей.</p>
Агрегация и композиция на самом деле являются частными случаями ассоциации. Это более конкретизированные отношения между объектами.</p>
В приведйнном приложении, в частности рассматриваютсяслучаи ассоциации: композиции и агрегации. </p>
<strong> Ассоциация </strong> – это когда один класс включает в себя другой класс в качестве одного из полей. </p>
 <em> Ассоциация описывается словом «имеет» </em>. <em> Класс CarOwner, в приведённом примере включает в себя поле класса Car, что является прмером ассоциации </em> </p>
 Вполне естественно, что он не будет являться наследником двигателя (хотя такая архитектура тоже возможна в некоторых ситуациях). <p>
 Выделяют два частных случая ассоциации: <em>композиция</em> и <em>агрегация</em>. <p>
 <strong> Композиция: </strong> – это когда двигатель не существует отдельно от автомобиля. Он создается при создании автомобиля и полностью управляется автомобилем. </em>
  В приедённом примере, экземпляр двигателя <em> car </em> будет создаваться в конструкторе автомобиля - это и будет являться композицией. </p>
  Автомобиль имеет двигатель.</p>
 ![композиция](https://user-images.githubusercontent.com/61631173/127641647-d661e103-8498-44e9-ad53-a171ffb8b3ef.JPG)</p>
  <strong> При композиции связь между объектами жёсткая</strong>, т.е. время жизненного цикла, вхожящего объекта совпадает с временем жизни родительского объекта, что предсталено в проиллюстрированном примере выше, где в конструкторе родительского класса создаётся новый оббъект класса двигатель, в данном случае жизнь вновь сохданного объекта прекратится при прекращении жизни класса родителя.</p>
  
 <strong> Агрегация: </strong>   — это отношение когда один объект является частью другого, но объекты могут сцществоаоть отдельно друг от друга.
 Класс владельца авто можно рассмотреть как пример агрегации, т.к. в отличии от конкретного двигателя автовладелец может иметь несколько автомобилей, на поведение автомобиля данное отношение ни как не скажется, в таком случае связб между автовладельцем и автомобилем менее жёсткая.</p>
 
![ассоциация_агрегация](https://user-images.githubusercontent.com/61631173/127651933-b2ceed79-2b97-4cb4-bb61-f393437c9286.JPG)</p>

В представленной реализации можно наблюдать, что в конструкторе класса входным параметром является экземпляр класса автомобиль, т.е. данный объект уже создан и получает какое то значение. В этом случае при прекращении действия экземпляра класса автовладельца, экземпляр класса автомобиля продолжит своё существование.</p>

<h2><strong>Инкапсуляция</strong></h2>

<em><strong> Инкапсуляция (encapsulation)</strong></em> - это сокрытие реализации класса и отделение его внутреннего представления от внешнего (интерфейса), это свойство которое позволяет закрыть доступ к полям и методам класса другим классам, а предоставлять им доступ только через интерфейс(метод). При использовании объектно ориентированного подхода не принято применять прямой доступ к свойствам какого либо класса из методов других классов. Для доступа к свойствам класса принято задействовать специальные методы этого класса для получения и изменения его свойств.</p>
 В прививедённом примере, в классе родителе Car, можно проследить описанное выше, а именно сокрытие полей родительского класса и предоставление доступа к ним через специальные методы сеттеры для установки значений и методы геттеры для получения значений. </p>
 Выше описнное определение можно разбить на два основных определения:</p>

1. <strong><em>Сокрытие реализации </strong></em>— это механизм для ограничения доступа к некоторым компонентам объекта. Сокрытие данных означает сокрытие от пользователя несущественных деталей и отображение ему только соответствующих данных. Сокрытие данных достигается посредством модификаторов доступа (private, public, protected, default-package), каждый из которых определяет свой уровень доступности.</p>

2. <strong><em>Инкапсуляция </strong></em> - это объединение данных и методов работы с этими данными в одной упаковке («капсуле»). В Java в роли упаковки-капсулы выступает класс. Класс содержит в себе и данные (поля класса), и методы для работы с этими данными. </p>
 Для достижения инкапсуляции в Java:</p>
Необходимо объявить переменные класса как private (в некоторых случаях можно protected).</p>
Предоставить public к методам установки и получения (сеттеру и геттеру) для изменения и просмотра значений переменных.</p>
 задание приватных полей, которые закроют прямой доступ к полям класса:</p>
 ![рожительский класс](https://user-images.githubusercontent.com/61631173/128559369-8a7565ca-7f24-47fe-83ec-c8f5db6acbbb.JPG)</p>
 предоставление доступа к полям класса через специальные методы для получения и задания значений полей класса: </p>
![геттеры и сеттеры класса](https://user-images.githubusercontent.com/61631173/128559388-295b468b-9fc5-40f7-a4b3-9243f668cab1.JPG)</p>
Таким образом можно выделить следующии иреимущества инкапсуляции:</p>
- Поля класса можно сделать только для чтения или только для записи.</p>
- Класс может иметь полный контроль над тем, что хранится в его полях.</p>
<h2><strong>Полиморфизм</strong></h2>
<strong><em>Полиморфизм (polymorphism) (от греческого polymorphos) </strong></em> - это свойство, которое позволяет одно и то же имя использовать для решения двух или более схожих, но технически разных задач. Целью полиморфизма, применительно к объектно ориентированному программированию, является использование одного имени для задания общих для класса действий. Выполнение каждого конкретного действия будет определяться типом данных.</p>
В более общем смысле, концепцией полиморфизма является идея "один интерфейс, множество методов". Это означает, что можно создать общий интерфейс для группы
близких по смыслу действий.</p>
Для закрепления определения обратимся к созданному примеру и рассмотрим проявление полиморфизма в работе. </p>
В нашем случае примером полиморфизма можно назвать наследоание класса родителя <em>Car</em> классами <em>Truck </em>, <em>Sedan</em> и другими классами наследниками, которые расширяют класс родитель. При наследовании класса родителя можно наблюдать пеереопределение его методов в класах наследниках с их собственной реализацией по типу автомобиля.</p>

![полиморф_1](https://user-images.githubusercontent.com/61631173/128602823-6007d484-f393-41f1-9ea0-20ba231f5201.JPG)</p>

представленные методы будут переопределяться после наследования класса</p> 

![полиморф_2](https://user-images.githubusercontent.com/61631173/128602824-354156c4-265d-4476-8189-71b2922a7109.JPG)</p>

![полиморф_3](https://user-images.githubusercontent.com/61631173/128602959-8d9ebfb0-0a58-4209-9123-2e3f76fbbb9a.JPG)</p>

на примере видно переопределение и реализацию метода <em>gas()</em> в классе потомке <em>F1Car1 </em>.</p>
При дальнейшем рассуждении о потомках, можно отметить, что наследование<strong>extends</strong> классов не единственное применение полиморфизма в Java, т.к. есть ещё и реализация интерфейсов <strong>implements</strong>. Стоит вспомнить, что в Java не поддерживается множественное наследование — каждый тип может иметь одного родителя (суперкласс) и неограниченное количество наследников (подклассов).</p> Поэтому для добавления нескольких функциональностей в классы используются интерфейсы. Интерфейсы уменьшают связанность объектов с родителем по сравнению с наследованием и используются очень широко. В Java интерфейс является ссылочным типом, поэтому в программе может быть объявлен тип переменой типа интерфейса. Рассмотрим на имеющимся примере применение интерфейса, добавив в него пару методов.</p>
На реализованном примере находящимся, по ссылке https://github.com/Krassilnikov-AV/Java_Themes/tree/master/Java_Themes_OOP/src/main/java/oop/project_4_polimorphism </p>
рассмотрим детали полиморфизма при помощи реализации итерфейсов</p>

![image](https://user-images.githubusercontent.com/61631173/128606798-721b8bdb-3e2d-4cac-805f-17a8ea3a17b6.png)</p>

![полиморф_5](https://user-images.githubusercontent.com/61631173/128606842-156ad279-dc66-4aa1-a657-119c168ffa47.JPG)</p>

![полиморф_6](https://user-images.githubusercontent.com/61631173/128606877-a5ce66f5-42ef-4037-bdb5-ef6a5ea4e9ae.JPG)</p>

![полиморф_7](https://user-images.githubusercontent.com/61631173/128606949-9439f781-eb17-4c08-aaec-9dd34f502ae1.JPG)</p>

![полиморф_8](https://user-images.githubusercontent.com/61631173/128606951-8e34acff-d6b8-4a3c-ab6b-fb97a056a216.JPG)</p>

_ _ _ _ 

- <em>Interface_AbstractClass-> </p> https://github.com/Krassilnikov-AV/Java_Themes/tree/master/Java_Themes_Core/src/main/java/core/Interface_AbstractClass описание⬇️</em> </p>
1. Абстрактный класс - это класс, из которого нельзя создать экземпляр.</p>
2. Единственный способ использования - создание класса потомка.</p>
3. Абстракные классы применяются тогда, когда у родственных классов одна часть методов одинаковые, а другая часть методов отличается. Те методы, которые совпадают - можно реализовать в базовом абстрактном классе, а те, которые отличаются - реализовать в классах потомках. </p>

<em>Пример:</em>
  Фигура - абстрактная сущность, а круг или квадрат конкретная сущность. При рассчёте площади круга и квадрата разные формулы, а цвет фигуры может быть одной и той же функцией. И тогда метод получения цвета фигуры можно вынести в базовый абстрактный класс, а метод получения площади можно вынести в класс потомок.</p>
 4. Абстракные классы могут содержать абстрактные методы. Это такие методы, для которых есть только определение, но нет наполнения. Это способ заставить реализовать эти методы в классах потомках.  </p>
  При реализации сначало нужнон создавать интиерфейсы а потом абстракные классы.
  По причине того, что абстрактый класс, сущность узкая и при создании начинает "связывать руки"</p>
  !!!!! Создавать абстрактный класс нужно в том случае, если действительно в нем есть необходимость.
  
